use std::io::BufRead;
use std::path::PathBuf;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TemplateType {
    M4,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GeneratedFile {
    path: PathBuf,
    template_path: Option<PathBuf>,
    template_type: Option<TemplateType>,
}

impl std::fmt::Display for GeneratedFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} is generated", self.path.display())?;
        if let Some(template_path) = &self.template_path {
            write!(f, " from {}", template_path.display())?;
        }
        Ok(())
    }
}

impl std::error::Error for GeneratedFile {}

#[derive(Clone, PartialEq, Eq)]
pub struct FormattingUnpreservable {
    path: PathBuf,
    original_contents: Option<Vec<u8>>,
    rewritten_contents: Option<Vec<u8>>,
}

impl std::fmt::Debug for FormattingUnpreservable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FormattingUnpreservable")
            .field("path", &self.path)
            .field(
                "original_contents",
                &self
                    .original_contents
                    .as_deref()
                    .map(|x| std::str::from_utf8(x)),
            )
            .field(
                "rewritten_contents",
                &self
                    .rewritten_contents
                    .as_deref()
                    .map(|x| std::str::from_utf8(x)),
            )
            .finish()
    }
}

impl std::fmt::Display for FormattingUnpreservable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Unable to preserve formatting in {}",
            self.path.display()
        )
    }
}

impl std::error::Error for FormattingUnpreservable {}

impl FormattingUnpreservable {
    pub fn diff(&self) -> Vec<String> {
        let original_lines = std::str::from_utf8(self.original_contents.as_deref().unwrap_or(b""))
            .unwrap()
            .split_inclusive('\n')
            .collect::<Vec<_>>();
        let rewritten_lines =
            std::str::from_utf8(self.rewritten_contents.as_deref().unwrap_or(b""))
                .unwrap()
                .split_inclusive('\n')
                .collect::<Vec<_>>();

        difflib::unified_diff(
            original_lines.as_slice(),
            rewritten_lines.as_slice(),
            "original",
            "rewritten",
            "",
            "",
            3,
        )
    }
}

/// Check that formatting can be preserved.
///
/// # Arguments
/// * `rewritten_text` - The rewritten file contents
/// * `text` - The original file contents
/// * `path` - Path to the file (unused, just passed to the exception)
/// * `allow_reformatting` - Whether to allow reformatting
fn check_preserve_formatting(
    rewritten_text: Option<&[u8]>,
    text: Option<&[u8]>,
    path: &std::path::Path,
    allow_reformatting: bool,
) -> Result<(), FormattingUnpreservable> {
    if rewritten_text == text {
        return Ok(());
    }
    if allow_reformatting {
        return Ok(());
    }
    Err(FormattingUnpreservable {
        path: path.to_path_buf(),
        original_contents: text.map(|x| x.to_vec()),
        rewritten_contents: rewritten_text.map(|x| x.to_vec()),
    })
}

pub const DO_NOT_EDIT_SCAN_LINES: usize = 20;

/// Check if a file is generated from another file.
///
/// # Arguments
/// * `path` - Path to the file to check
///
/// # Errors
/// * `GeneratedFile` - when a generated file is found
pub fn check_generated_file(path: &std::path::Path) -> Result<(), GeneratedFile> {
    for ext in ["in", "m4", "stub"] {
        let template_path = path.with_extension(ext);
        if template_path.exists() {
            return Err(GeneratedFile {
                path: path.to_path_buf(),
                template_path: Some(template_path),
                template_type: match ext {
                    "m4" => Some(TemplateType::M4),
                    _ => None,
                },
            });
        }
    }

    match std::fs::File::open(path) {
        Ok(f) => {
            let buf = std::io::BufReader::new(f);
            for l in buf.lines().take(DO_NOT_EDIT_SCAN_LINES) {
                let l = if let Ok(l) = l { l } else { continue };
                if l.contains("DO NOT EDIT")
                    || l.contains("Do not edit!")
                    || l.contains("This file is autogenerated")
                {
                    return Err(GeneratedFile {
                        path: path.to_path_buf(),
                        template_path: None,
                        template_type: None,
                    });
                }
            }
        }
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {}
        Err(e) => panic!("Error reading file: {}", e),
    }
    Ok(())
}

#[derive(Debug)]
enum EditorError {
    GeneratedFile(GeneratedFile),
    FormattingUnpreservable(FormattingUnpreservable),
    IoError(std::io::Error),
}

impl std::fmt::Display for EditorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EditorError::GeneratedFile(e) => write!(
                f,
                "File {} is generated from another file",
                e.path.display()
            ),
            EditorError::FormattingUnpreservable(e) => {
                write!(f, "Unable to preserve formatting in {}", e.path.display())
            }
            EditorError::IoError(e) => write!(f, "I/O error: {}", e),
        }
    }
}

impl std::error::Error for EditorError {}

impl From<GeneratedFile> for EditorError {
    fn from(e: GeneratedFile) -> Self {
        EditorError::GeneratedFile(e)
    }
}

impl From<FormattingUnpreservable> for EditorError {
    fn from(e: FormattingUnpreservable) -> Self {
        EditorError::FormattingUnpreservable(e)
    }
}

impl From<std::io::Error> for EditorError {
    fn from(e: std::io::Error) -> Self {
        EditorError::IoError(e)
    }
}

/// Edit a formatted file.
///
/// # Arguments
/// * `path` - Path to the file
/// * `original_contents` - The original contents of the file
/// * `rewritten_contents` - The contents rewritten with our parser/serializer
/// * `updated_contents` - Updated contents rewritten with our parser/serializer after changes were
///   made
/// * `allow_generated` - Do not raise `GeneratedFile` when encountering a generated file
/// * `allow_reformatting` - Whether to allow reformatting of the file
///
/// # Returns
/// `true` if the file was changed, `false` otherwise
pub fn edit_formatted_file(
    path: &std::path::Path,
    original_contents: Option<&[u8]>,
    rewritten_contents: Option<&[u8]>,
    updated_contents: Option<&[u8]>,
    allow_generated: bool,
    allow_reformatting: bool,
) -> Result<bool, EditorError> {
    if updated_contents == rewritten_contents || updated_contents == original_contents {
        return Ok(false);
    }
    if !allow_generated {
        check_generated_file(path)?;
    }
    let mut updated_contents = updated_contents.map(std::borrow::Cow::Borrowed);
    match check_preserve_formatting(
        rewritten_contents,
        original_contents,
        path,
        allow_reformatting,
    ) {
        Ok(()) => {}
        Err(e) => {
            if rewritten_contents.is_none()
                || original_contents.is_none()
                || updated_contents.is_none()
            {
                return Err(e.into());
            }
            #[cfg(feature = "merge3")]
            {
                // Run three way merge
                log::debug!("Unable to preserve formatting; falling back to merge3");
                let rewritten_lines = rewritten_contents
                    .unwrap()
                    .split_inclusive(|&x| x == b'\n')
                    .collect::<Vec<_>>();
                let original_lines = original_contents
                    .unwrap()
                    .split_inclusive(|&x| x == b'\n')
                    .collect::<Vec<_>>();
                let updated_lines = updated_contents
                    .as_ref()
                    .unwrap()
                    .split_inclusive(|&x| x == b'\n')
                    .collect::<Vec<_>>();
                let m3 = merge3::Merge3::new(
                    rewritten_lines.as_slice(),
                    original_lines.as_slice(),
                    updated_lines.as_slice(),
                );
                if m3
                    .merge_regions()
                    .iter()
                    .any(|x| matches!(x, merge3::MergeRegion::Conflict { .. }))
                {
                    return Err(e.into());
                }
                updated_contents = Some(std::borrow::Cow::Owned(
                    m3.merge_lines(false, &merge3::StandardMarkers::default())
                        .join(&b"\n"[..]),
                ));
            }
            #[cfg(not(feature = "merge3"))]
            {
                log::debug!("Unable to preserve formatting; merge3 feature not enabled");
                return Err(e.into());
            }
        }
    }

    if let Some(updated_contents) = updated_contents {
        std::fs::write(path, updated_contents)?;
    } else {
        std::fs::remove_file(path)?;
    }
    Ok(true)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_formatting_same() {
        assert_eq!(
            Ok(()),
            check_preserve_formatting(
                Some(b"FOO  "),
                Some(b"FOO  "),
                std::path::Path::new("debian/blah"),
                false
            )
        );
    }

    #[test]
    fn test_formatting_different() {
        assert_eq!(
            Err(FormattingUnpreservable {
                original_contents: Some("FOO \n".as_bytes().to_vec()),
                rewritten_contents: Some("FOO  \n".as_bytes().to_vec()),
                path: std::path::PathBuf::from("debian/blah")
            }),
            check_preserve_formatting(
                Some(b"FOO  \n"),
                Some(b"FOO \n"),
                std::path::Path::new("debian/blah"),
                false
            )
        );
    }

    #[test]
    fn test_diff() {
        let e = FormattingUnpreservable {
            path: "debian/blah".into(),
            original_contents: Some(b"FOO X\n".to_vec()),
            rewritten_contents: Some(b"FOO  X\n".to_vec()),
        };
        assert_eq!(
            e.diff(),
            vec![
                "--- original\t\n",
                "+++ rewritten\t\n",
                "@@ -1 +1 @@\n",
                "-FOO X\n",
                "+FOO  X\n",
            ]
        );
    }

    #[test]
    fn test_reformatting_allowed() {
        assert_eq!(
            Ok(()),
            check_preserve_formatting(
                Some(b"FOO  "),
                Some(b"FOO "),
                std::path::Path::new("debian/blah"),
                true
            )
        );
    }

    #[test]
    fn test_generated_control_file() {
        let td = tempfile::tempdir().unwrap();
        std::fs::create_dir(td.path().join("debian")).unwrap();
        std::fs::write(td.path().join("debian/control.in"), "Source: blah\n").unwrap();
        assert_eq!(
            Err(GeneratedFile {
                path: td.path().join("debian/control"),
                template_path: Some(td.path().join("debian/control.in")),
                template_type: None,
            }),
            check_generated_file(&td.path().join("debian/control"))
        );
    }

    #[test]
    fn test_generated_file_missing() {
        let td = tempfile::tempdir().unwrap();
        std::fs::create_dir(td.path().join("debian")).unwrap();
        assert_eq!(
            Ok(()),
            check_generated_file(&td.path().join("debian/control"))
        );
    }

    #[test]
    fn test_do_not_edit() {
        let td = tempfile::tempdir().unwrap();
        std::fs::create_dir(td.path().join("debian")).unwrap();
        std::fs::write(
            td.path().join("debian/control"),
            "# DO NOT EDIT\nSource: blah\n",
        )
        .unwrap();
        assert_eq!(
            Err(GeneratedFile {
                path: td.path().join("debian/control"),
                template_path: None,
                template_type: None,
            }),
            check_generated_file(&td.path().join("debian/control"))
        );
    }

    #[test]
    fn test_do_not_edit_after_header() {
        // check_generated_file() only checks the first 20 lines.
        let td = tempfile::tempdir().unwrap();
        std::fs::create_dir(td.path().join("debian")).unwrap();
        std::fs::write(
            td.path().join("debian/control"),
            "\n".repeat(50) + "# DO NOT EDIT\nSource: blah\n",
        )
        .unwrap();
        assert_eq!(
            Ok(()),
            check_generated_file(&td.path().join("debian/control"))
        );
    }

    #[test]
    fn test_unchanged() {
        let td = tempfile::tempdir().unwrap();
        std::fs::write(td.path().join("a"), "some content\n").unwrap();
        assert!(!edit_formatted_file(
            &td.path().join("a"),
            Some("some content\n".as_bytes()),
            Some("some content reformatted\n".as_bytes()),
            Some("some content\n".as_bytes()),
            false,
            false
        )
        .unwrap());
        assert!(!edit_formatted_file(
            &td.path().join("a"),
            Some("some content\n".as_bytes()),
            Some("some content\n".as_bytes()),
            Some("some content\n".as_bytes()),
            false,
            false
        )
        .unwrap());
        assert!(!edit_formatted_file(
            &td.path().join("a"),
            Some("some content\n".as_bytes()),
            Some("some content reformatted\n".as_bytes()),
            Some("some content reformatted\n".as_bytes()),
            false,
            false
        )
        .unwrap());
    }

    #[test]
    fn test_changed() {
        let td = tempfile::tempdir().unwrap();
        std::fs::write(td.path().join("a"), "some content\n").unwrap();
        assert!(edit_formatted_file(
            &td.path().join("a"),
            Some("some content\n".as_bytes()),
            Some("some content\n".as_bytes()),
            Some("new content\n".as_bytes()),
            false,
            false
        )
        .unwrap());
        assert_eq!(
            "new content\n",
            std::fs::read_to_string(td.path().join("a")).unwrap()
        );
    }

    #[test]
    fn test_unformattable() {
        let td = tempfile::tempdir().unwrap();
        assert!(matches!(
            edit_formatted_file(
                &td.path().join("a"),
                Some(b"some content\n"),
                Some(b"reformatted content\n"),
                Some(b"new content\n"),
                false,
                false
            )
            .unwrap_err(),
            EditorError::FormattingUnpreservable(FormattingUnpreservable { .. })
        ));
    }
}
